# geopandas specific
import geopandas as gpd
from geopandas import GeoDataFrame

# grabbing data
import sqlalchemy as sa
from ingester3.config import source_db_path

# grabbing predictions and basics
import pandas as pd
from views_forecasts.extensions import *
import numpy as np

# mapping
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable

# month identification
from ingester3.ViewsMonth import ViewsMonth

# communication with wandb
import wandb

from matplotlib.colors import SymLogNorm


def get_the_geom():
    engine = sa.create_engine(source_db_path)
    gdf_pid = gpd.GeoDataFrame.from_postgis(
        "SELECT id as priogrid_gid, in_africa, in_me, geom FROM prod.priogrid",
        engine,
        geom_col='geom'
    )
    gdf_pid = gdf_pid.to_crs(4326)

    gdf_ci_master = gpd.GeoDataFrame.from_postgis(
        "SELECT id as country_id, name, in_africa, in_me, geom FROM prod.country WHERE gweyear=(SELECT max(gweyear) FROM prod.country)",
        engine,
        geom_col='geom'
    )
    gdf_ci_master = gdf_ci_master.to_crs(4326)

    return gdf_pid, gdf_ci_master


def make_a_date(month_id):
    a = f"{ViewsMonth(month_id).month}/{ViewsMonth(month_id).year}"
    return a


def make_a_data_slice_pgm(df, month):

    gdf_pid, gdf_ci_master = get_the_geom()

    df2 = pd.merge(df, gdf_pid, left_on="priogrid_id",
                   right_on='priogrid_gid', how='left')
    df3 = df2.loc[df2['month_id'] == month]
    df3 = GeoDataFrame(df3).set_geometry('geom')
    return df3


def map_fatality_specific(data, column, month, step):

    data_run = make_a_data_slice_pgm(data, month)

    standard_scale = [0, 100, 300, 1000, 3000]
    standard_labels = ['0', '100', '300', '1000', '3000']
    map_dictionary = dict(zip(standard_scale, standard_labels))

    vmin = min(map_dictionary)
    vmax = max(map_dictionary)

    norm = SymLogNorm(linthresh=1, vmin=vmin, vmax=vmax)

    gdf_pid, gdf_ci_master = get_the_geom()

    fig, ax = plt.subplots(1, 1, figsize=(20, 20))

    # bbox dimensions for the AME
    XMIN, XMAX, YMIN, YMAX = -18.5, 64.0, -35.5, 43.0

    title = f"Fatalities predicted for {make_a_date(month)} at step {step}"

    ax.set_xlim(XMIN, XMAX)
    ax.set_ylim(YMIN, YMAX)

    divider = make_axes_locatable(ax)

    cax = divider.append_axes("right", size="5%", pad=0.1)

    data_run.plot(
        column=column,
        ax=ax,
        norm=norm,
        legend=False,
        cax=cax,
        cmap='rainbow',
        legend_kwds={"label": "", "orientation": "horizontal"})

    ax.set_title(title, fontsize=15, y=1)
    ax.set_xticks([])
    ax.set_yticks([])

    # ensure that the colormap is scaled the same as the map
    sm = plt.cm.ScalarMappable(cmap='rainbow', norm=norm)
    sm._A = []
    cbr = fig.colorbar(sm, cax=cax)
    # to do at a later time, experiment with separation of tick labels and tick params
    cbr.ax.tick_params()

    # country and priogrid boundaries
    gdf_ci_master.boundary.plot(ax=ax, color='black', linewidth=1.1)
    gdf_pid.boundary.plot(ax=ax, color='black', linewidth=0.3)

    return (fig)


def visualize(target, para_transformed, by_group=False, b=1, a=0, plot_additional=False):
    '''
    :param target: 'calib' or 'test'
    :param para_transformed: the dict that is generated by transform_data
    :param retransform: transform the data back if True
    :param retransform_by_group: transform the data back by country_id if True. Make sure it is the same value in transform_data
    '''

    print(f'Visualizing model {wandb.config["modelname"]}')
    if target not in ['calib', 'test']:
        raise ValueError("Wrong target name, only support 'calib' and 'test'.")

    transform = wandb.config['transform']
    steps = wandb.config['steps']
    run_id = wandb.config['run_id']
    level = wandb.config['level']
    stepcols = [wandb.config['depvar']]

    print('i successfully fetched run definitions')

    for step in steps:
        stepcols.append('step_pred_' + str(step))
    pred_cols = [f'step_pred_{str(i)}' for i in steps]

    print(pred_cols)

    name = wandb.config[f'predstore_{target}_{transform}']

    # the following fetches the data from storage
    df = pd.DataFrame.forecasts.read_store(run=run_id, name=name).replace([
        np.inf, -np.inf], 0)[stepcols]
    months = df.index.levels[0].tolist()
    df = df.reset_index()

    print('i fetched the data')

    gdf_pid, gdf_ci_master = get_the_geom()

    print('i fetched geometries')

    if plot_additional:
        step_preds = [f'step_pred_{i}' for i in steps]
        # Temporarily only predict the first month
        for month in [months[0]]:
            print("month", month)
            for step in [step_preds[0]]:
                print("step", step)
                step_numeric = int(step.strip('step_pred_'))
                fig_export = map_fatality_specific(
                    data=df, column=step, month=month, step=step_numeric)
                wandb.log({f'month_{month}_{step}': wandb.Image(fig_export)})
